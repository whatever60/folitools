from pathlib import Path

import pandas as pd
import polars as pl

from .utils import expand_path_to_list


def deduplicate_umi(
    group_count: pl.DataFrame | pl.LazyFrame,
) -> pd.DataFrame:
    gene_counts = (
        group_count.select(["gene", "final_umi"])
        .unique()
        .group_by("gene")
        .agg(pl.count().alias("umi_count"))
        # .len()
        # .rename({"len": "umi_count"})
    )
    if isinstance(gene_counts, pl.LazyFrame):
        gene_counts = gene_counts.collect()
    gene_counts = (
        gene_counts.select(["gene", "umi_count"]).to_pandas().set_index("gene")
    )
    return gene_counts


def count_umi(group_count: pl.DataFrame | pl.LazyFrame) -> pd.DataFrame:
    result = group_count.select(pl.struct(["gene", "final_umi"]).value_counts()).select(
        umi=pl.col("gene").struct.field("gene").struct.field("gene")
        + ":"
        + pl.col("gene").struct.field("gene").struct.field("final_umi"),
        count=pl.col("gene").struct.field("count"),
    )
    if isinstance(result, pl.LazyFrame):
        result = result.collect()
    return result.to_pandas().set_index("umi")


def count_gene(group_count: pl.DataFrame | pl.LazyFrame) -> pd.DataFrame:
    result = group_count.select(pl.col("gene").value_counts()).select(
        gene=pl.col("gene").struct.field("gene"),
        count=pl.col("gene").struct.field("count"),
    )
    if isinstance(result, pl.LazyFrame):
        result = result.collect()
    return result.to_pandas().set_index("gene")


def process_count_file(fp: str) -> pd.Series:
    """
    Process a single count file—either raw UMI records or a precomputed gene to count table.

    Args:
        fp: Path to a tab-delimited count file.
            If the header matches
            ["read_id", "contig", "position", "gene", "umi",
             "umi_count", "final_umi", "final_umi_count", "unique_id"]
            it will compute per-gene UMI counts. Otherwise it expects
            a two-column table (gene and count).

    Returns:
        pd.Series: Index is gene, values are umi_count, name is sample (file stem).
    """
    sample = Path(fp).stem.split(".")[0]
    expected = [
        "read_id",
        "contig",
        "position",
        "gene",
        "umi",
        "umi_count",
        "final_umi",
        "final_umi_count",
        "unique_id",
    ]

    header = pd.read_csv(fp, nrows=0, sep="\t").columns.tolist()

    if header == expected:  # A table generated by `umi_tools group`
        df = pl.scan_csv(fp, separator="\t").filter(pl.col("gene") != "Unassigned")
        gene_counts = deduplicate_umi(df)
        s = gene_counts["umi_count"]
    else:  # A table generated by `umi_tools count`
        df = pd.read_csv(fp, sep="\t", index_col=0)
        if df.shape[1] != 1:
            raise ValueError(f"Expected 1 column in {fp!r}, got {df.shape[1]}")
        df.columns = [sample]
        s = df.iloc[:, 0]

    s.name = sample
    return s


def id2symbol_from_gencode_gtf(gtf: str) -> dict[str, str]:
    id2symbol: dict[str, str] = {}
    gtf_df = pl.read_csv(
        gtf,
        comment_prefix="#",
        has_header=False,
        new_columns=[
            "seqname",
            "source",
            "feature",
            "start",
            "end",
            "score",
            "strand",
            "frame",
            "attribute",
        ],
        separator="\t",
    ).to_pandas()
    gtf_df["gene_id"] = gtf_df.attribute.str.extract(r'gene_id "(.*?)";')
    gtf_df["gene_symbol"] = gtf_df.attribute.str.extract(r'gene_name "(.*?)";')
    for gene_id, gene_symbol in gtf_df[["gene_id", "gene_symbol"]].values:
        if not gene_id:
            continue
        gene_id_nover = gene_id.split(".")[0]
        if gene_id_nover in id2symbol:
            assert id2symbol[gene_id_nover] == gene_symbol
        else:
            id2symbol[gene_id_nover] = gene_symbol
    return id2symbol


def read_counts(input_: str | list[str], gtf: str | None = None) -> pd.DataFrame:
    """
    Read one or more count files into a sample x gene count matrix.

    Args:
        input_: A single file path, a glob pattern, or a list of file paths.
        gtf: Optional path to a GTF file for gene_id→gene_symbol mapping.
             If provided, gene IDs (without version) will be renamed to symbols.

    Returns:
        pd.DataFrame: Rows are samples, columns are genes (symbols if gtf provided),
                      values are integer UMI counts.
    """
    files = expand_path_to_list(input_)
    # process each file
    series_list = [process_count_file(fp) for fp in files]

    # combine into matrix: samples × genes
    matrix = pd.concat(series_list, axis=1).fillna(0).astype(int).transpose()

    # rename columns to gene symbols if map provided
    if gtf:
        id2symbol = id2symbol_from_gencode_gtf(gtf)
        matrix.columns = [
            id2symbol.get(col.split(".")[0], col) for col in matrix.columns
        ]
        # Aggregate by gene symbol if multiple IDs map to the same symbol
        matrix = (
            matrix.transpose()
            .groupby(level=0, sort=False)
            .mean()
            .transpose()
            .astype(int)
        )
    # reorder columns by average rel ab
    rel_ab = matrix.divide(matrix.sum(axis=1), axis=0)
    matrix = matrix[rel_ab.mean(axis=0).sort_values(ascending=False).index]

    return matrix
