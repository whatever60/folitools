from pathlib import Path

import pandas as pd
import polars as pl
from wcmatch import glob


def process_count_file(fp: str) -> pd.Series:
    """
    Process a single count file—either raw UMI records or a precomputed gene to count table.

    Args:
        fp: Path to a tab-delimited count file.
            If the header matches
            ["read_id", "contig", "position", "gene", "umi",
             "umi_count", "final_umi", "final_umi_count", "unique_id"]
            it will compute per-gene UMI counts. Otherwise it expects
            a two-column table (gene and count).

    Returns:
        pd.Series: Index is gene, values are umi_count, name is sample (file stem).
    """
    sample = Path(fp).stem
    expected = [
        "read_id",
        "contig",
        "position",
        "gene",
        "umi",
        "umi_count",
        "final_umi",
        "final_umi_count",
        "unique_id",
    ]

    header = pd.read_csv(fp, nrows=0, sep="\t").columns.tolist()

    if header == expected:  # A table generated by `umi_tools count`
        df = pl.scan_csv(fp, separator="\t")
        gene_counts = (
            df.select(["gene", "unique_id"])
            .unique()
            .group_by("gene")
            .agg(pl.count().alias("umi_count"))
        )
        s = gene_counts.collect().to_pandas().set_index("gene")["umi_count"]
    else:  # A table generated by `umi_tools group`
        df = pd.read_csv(fp, sep="\t", index_col=0)
        if df.shape[1] != 1:
            raise ValueError(f"Expected 1 column in {fp!r}, got {df.shape[1]}")
        df.columns = [sample]
        s = df.iloc[:, 0]

    s.name = sample
    return s


def read_counts(input_: str | list[str], gtf: str | None = None) -> pd.DataFrame:
    """
    Read one or more count files into a sample x gene count matrix.

    Args:
        input_: A single file path, a glob pattern, or a list of file paths.
        gtf: Optional path to a GTF file for gene_id→gene_symbol mapping.
             If provided, gene IDs (without version) will be renamed to symbols.

    Returns:
        pd.DataFrame: Rows are samples, columns are genes (symbols if gtf provided),
                      values are integer UMI counts.
    """
    # build id→symbol map if requested
    id2symbol: dict[str, str] = {}
    if gtf is not None:
        gtf_df = pl.read_csv(
            gtf,
            comment_prefix="#",
            has_header=False,
            new_columns=[
                "seqname",
                "source",
                "feature",
                "start",
                "end",
                "score",
                "strand",
                "frame",
                "attribute",
            ],
            separator="\t",
        ).to_pandas()
        gtf_df["gene_id"] = gtf_df.attribute.str.extract(r'gene_id "(.*?)";')
        gtf_df["gene_symbol"] = gtf_df.attribute.str.extract(r'gene_name "(.*?)";')
        for gene_id, gene_symbol in gtf_df[["gene_id", "gene_symbol"]].values:
            if not gene_id:
                continue
            gene_id_nover = gene_id.split(".")[0]
            if gene_id_nover in id2symbol:
                assert id2symbol[gene_id_nover] == gene_symbol
            else:
                id2symbol[gene_id_nover] = gene_symbol

    # resolve input_ to list of files
    if isinstance(input_, str):
        p = Path(input_)
        if p.is_file():
            files = [str(p)]
        else:
            files = glob.glob(input_, flags=glob.EXTGLOB)
            if not files:
                raise FileNotFoundError(f"No files match: {input_!r}")
    else:
        files = list(input_)

    # process each file
    series_list = [process_count_file(fp) for fp in sorted(files)]

    # combine into matrix: samples × genes
    matrix = pd.concat(series_list, axis=1).fillna(0).astype(int).transpose()

    # rename columns to gene symbols if map provided
    if id2symbol:
        matrix.columns = [
            id2symbol.get(col.split(".")[0], col) for col in matrix.columns
        ]

    return matrix
    